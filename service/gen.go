// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates api for Service. It can be invoked by running
// go generate
package main

import (
	"fmt"
	"go/importer"
	"html/template"
	"log"
	"os"
	"reflect"
	"strings"

	"github.com/ianic/api_code_gen/service"
)

type Generator struct {
	svc        interface{}
	dtoPkgPath string
}

func inspectMethods(i interface{}) ([]method, error) {
	v := reflect.ValueOf(i)
	fmt.Println("kind", v.Type().PkgPath())
	var ms []method
	for i := 0; i < v.NumMethod(); i++ {
		tm := v.Type().Method(i)
		m := v.Method(i)

		if m.Type().NumIn() != 1 &&
			m.Type().NumOut() != 2 &&
			m.Type().Out(1).String() != "error" {
			return nil, fmt.Errorf("unsupported signature for method %s", tm.Name)
		}

		ms = append(ms, method{
			Name: tm.Name,
			In:   m.Type().In(0).String(),
			Out:  m.Type().Out(0).String(),
		})
	}
	return ms, nil
}

func findErrors(pkgPath string) ([]string, error) {
	var es []string
	pkg, err := importer.Default().Import(pkgPath)
	if err != nil {
		return nil, err
	}
	for _, n := range pkg.Scope().Names() {
		if strings.HasPrefix(n, "Err") {
			es = append(es, fmt.Sprintf("%s.%s", pkg.Name(), n))
		}
	}
	return es, nil
}

func namesFor(i interface{}) (string, string) {
	typ := reflect.TypeOf(i).String()
	if strings.HasPrefix(typ, "*") {
		typ = typ[1:]
	}
	p := strings.Split(typ, ".")
	// TODO sta ako nije len = 2
	return p[0], p[1]
}

func main() {
	dtoPath := "github.com/ianic/api_code_gen/service/dto"
	svc := &service.Service{}

	ms, err := inspectMethods(svc)
	if err != nil {
		log.Fatal(err)
	}

	es, err := findErrors(dtoPath)
	if err != nil {
		log.Fatal(err)
	}

	pkg, stc := namesFor(svc)

	d := data{
		Package: pkg,
		Struct:  stc,
		Imports: []string{dtoPath},
		Methods: ms,
		Errors:  es,
	}

	clientTemplate.Execute(os.Stdout, d)
	serverTemplate.Execute(os.Stdout, d)
}

type data struct {
	Package string
	Struct  string
	Imports []string
	Methods []method
	Errors  []string
}

type method struct {
	Name string
	In   string
	Out  string
}

var clientTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package api

import (
	"reflect"
  "errors"

	"github.com/minus5/svckit/types/registry"
{{- range .Imports }}
  "{{ . }}"
{{- end }}
)

type transport interface {
  Call(req interface{}, rsp interface{}) error
  Close()
}

type Client struct {
  t transport
}

func NewClient(r transport) *Client {
  return &Client{t: r}
}

{{- range .Methods }}

func (c *Client) {{.Name}}(req {{ .In }}) ({{ .Out }}, error) {
  rsp := &{{ .Out }}{}
  if err := c.t.Call(req, rsp); err != nil {
    return nil, err
  }
  return *rsp, nil
}
{{- end }}

var (
	typeRegistry = registry.New()
)

func init() {
	typeRegistry.Add([]interface{}{
  {{- range .Methods }}
		{{ .In }},
  {{- end }}
	})
}

func NameFor(i interface{}) string {
	return typeRegistry.NameFor(i)
}

func TypeFor(typ string) reflect.Type {
	return typeRegistry.TypeFor(typ)
}

func ParseError(text string) error {
  if text == "" {
    return nil
  }
  switch text {
{{- range .Errors }}
  case {{ . }}.Error():
    return {{ . }}
{{- end }}
  }
  return errors.New(text)
}
`))

var serverTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package {{.Package}}

import (
	"fmt"

{{- range .Imports }}
  "{{ . }}"
{{- end }}
)

func (s *{{.Struct}}) Serve(i interface{}) (interface{}, error) {
	switch req := i.(type) {
  {{- range .Methods }}
	case *{{ .In }}:
    return s.{{.Name}}(req)
  {{- end }}
	default:
		return nil, fmt.Errorf("unknown type %T", req)
	}
}
`))

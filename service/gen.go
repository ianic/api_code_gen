// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates api for Service. It can be invoked by running
// go generate
package main

import (
	"fmt"
	"go/importer"
	"html/template"
	"os"
	"reflect"

	"github.com/ianic/api_code_gen/service"
)

func main() {
	//fmt.Printf("evo me u gen.go\n")

	v := reflect.ValueOf(&service.Service{})

	//fmt.Println("num method", v, v.NumMethod())
	//fmt.Println("num method", v, v.Type().NumMethod())
	//fmt.Println(t, t.NumMethod())

	var ms []method
	for i := 0; i < v.NumMethod(); i++ {
		tm := v.Type().Method(i)
		m := v.Method(i)

		ms = append(ms, method{
			Name: tm.Name,
			In:   m.Type().In(0).String(),
			Out:  m.Type().Out(0).String(),
		})

		//fmt.Println("method", i, tm.Name, tm.PkgPath, tm.Func, tm.Type, tm.Index)
		//fmt.Println("method name:", tm.Name)
		fmt.Printf("%s\n", tm.Name)
		for i := 0; i < m.Type().NumIn(); i++ {
			t := m.Type().In(i)
			//fmt.Println("method in type", i, t, t.String())

			fmt.Printf("\t in %s pkgpath:%s\n", t.String(), t.PkgPath())
		}
		for i := 0; i < m.Type().NumOut(); i++ {
			t := m.Type().Out(i)
			fmt.Printf("\t out %s\n", t.String())
			//fmt.Println("method out type", i, t, t.String())
		}
	}

	//v = reflect.ValueOf(dto.ErrOverflow)
	//fmt.Println(v.)

	// //pkg, err := build.Import("github.com/ianic/api_code_gen/service", "", 0)
	pkg, err := importer.Default().Import("github.com/ianic/api_code_gen/service/dto")
	if err != nil {
		fmt.Printf("error: %s\n", err.Error())
		return
	}
	fmt.Println(pkg)
	for _, declName := range pkg.Scope().Names() {
		fmt.Println(declName)
	}

	clientTemplate.Execute(os.Stdout, struct {
		Methods []method
	}{ms})
}

type method struct {
	Name string
	In   string
	Out  string
}

var clientTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package api

type transport interface {
  Call(req interface{}, rsp interface{}) error
  Close()
}

type Client struct {
  t transport
}

func NewClient(r transport) *Client {
  return &Client{t: r}
}

{{- range .Methods }}
func (c *Client) {{.Name}}(req {{ .In }}) ({{ .Out }}, error) {
  rsp := &{{ .Out }}{}
  if err := c.t.Call(req, rsp); err != nil {
    return nil, err
  }
  return *rsp, nil
}
{{- end }}
`))

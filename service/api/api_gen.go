// Code generated by go generate; DO NOT EDIT.
package api

import (
	"encoding/json"
)

type transport interface {
	Call(string, []byte) ([]byte, error)
	Close()
}

type Client struct {
	t transport
}

func NewClient(r transport) *Client {
	return &Client{t: r}
}

func (c *Client) Add(req TwoReq) (*OneRsp, error) {
	rsp := new(OneRsp)
	if err := c.call("Add", req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) Cube(req int) (*int, error) {
	rsp := new(int)
	if err := c.call("Cube", req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) Multiply(req TwoReq) (*OneRsp, error) {
	rsp := new(OneRsp)
	if err := c.call("Multiply", req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) Multiply2(req TwoReq) (*int, error) {
	rsp := new(int)
	if err := c.call("Multiply2", req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) call(typ string, req, rsp interface{}) error {
	reqBuf, err := json.Marshal(req)
	if err != nil {
		return err
	}
	rspBuf, err := c.t.Call(typ, reqBuf)
	if err != nil {
		return err
	}
	if err := json.Unmarshal(rspBuf, rsp); err != nil {
		return err
	}
	return nil
}

func (c *Client) Close() {
	c.t.Close()
}

func parseError(err error) error {
	if err == nil {
		return nil
	}
	switch err.Error() {
	case ErrOverflow.Error():
		return ErrOverflow
	case ErrTransport.Error():
		return ErrTransport
	}
	return err
}

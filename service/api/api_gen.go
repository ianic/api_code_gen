// Code generated by go generate; DO NOT EDIT.
package api

import (
	"encoding/json"
)

const (
	MethodAdd       = "Add"
	MethodCube      = "Cube"
	MethodMultiply  = "Multiply"
	MethodMultiply2 = "Multiply2"
)

type transport interface {
	Call(string, []byte) ([]byte, error)
	Close()
}

type Client struct {
	t transport
}

func NewClient(r transport) *Client {
	return &Client{t: r}
}

func (c *Client) Add(req TwoReq) (*OneRsp, error) {
	rsp := new(OneRsp)
	if err := c.call(MethodAdd, req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) Cube(req int) (*int, error) {
	rsp := new(int)
	if err := c.call(MethodCube, req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) Multiply(req TwoReq) (*OneRsp, error) {
	rsp := new(OneRsp)
	if err := c.call(MethodMultiply, req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) Multiply2(req TwoReq) (*int, error) {
	rsp := new(int)
	if err := c.call(MethodMultiply2, req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) call(method string, req, rsp interface{}) error {
	reqBuf, err := Marshal(req)
	if err != nil {
		return err
	}
	rspBuf, err := c.t.Call(method, reqBuf)
	if err != nil {
		return err
	}
	if err := Unmarshal(rspBuf, rsp); err != nil {
		return err
	}
	return nil
}

func (c *Client) Close() {
	c.t.Close()
}

func parseError(err error) error {
	if err == nil {
		return nil
	}
	switch err.Error() {
	case ErrOverflow.Error():
		return ErrOverflow
	case ErrTransport.Error():
		return ErrTransport
	}
	return err
}

func Marshal(v interface{}) ([]byte, error) {
	return json.Marshal(v)
}

func Unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}

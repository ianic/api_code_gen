// Code generated by go generate; DO NOT EDIT.
package api

import (
	"encoding/json"
	"errors"
)

// method names constants
const (
	MethodAdd        = "Add"
	MethodCube       = "Cube"
	MethodMultiply   = "Multiply"
	MethodMultiply2  = "Multiply2"
	transportRetries = 128
)

// trasport specific errors
var (
	ErrTransportTimeout = errors.New("transport timeout")
	ErrTransport        = errors.New("transport error")
)

type transport interface {
	Call(string, []byte) ([]byte, error)
	Close()
}

type Client struct {
	t transport
}

func NewClient(r transport) *Client {
	return &Client{t: r}
}

func (c *Client) Add(req TwoReq) (*OneRsp, error) {
	rsp := new(OneRsp)
	if err := c.call(MethodAdd, req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) Cube(req int) (*int, error) {
	rsp := new(int)
	if err := c.call(MethodCube, req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) Multiply(req TwoReq) (*OneRsp, error) {
	rsp := new(OneRsp)
	if err := c.call(MethodMultiply, req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) Multiply2(req TwoReq) (*int, error) {
	rsp := new(int)
	if err := c.call(MethodMultiply2, req, rsp); err != nil {
		return nil, parseError(err)
	}
	return rsp, nil
}

func (c *Client) call(method string, req, rsp interface{}) error {
	reqBuf, err := Marshal(req)
	if err != nil {
		return err
	}
	var rspBuf []byte
	retries := 0
	for {
		var err error
		rspBuf, err = c.t.Call(method, reqBuf)
		if err != nil {
			if err == ErrTransportTimeout && retries < transportRetries {
				retries++
				continue
			}
			if err == ErrTransportTimeout {
				return ErrTransport
			}
			return err
		}
		break
	}
	if err := Unmarshal(rspBuf, rsp); err != nil {
		return err
	}
	return nil
}

func (c *Client) Close() {
	c.t.Close()
}

func parseError(err error) error {
	if err == nil {
		return nil
	}
	switch err.Error() {
	case ErrOverflow.Error():
		return ErrOverflow
	}
	return err
}

func Marshal(v interface{}) ([]byte, error) {
	return json.Marshal(v)
}

func Unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}

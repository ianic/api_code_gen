package gen

import (
	"fmt"
	"go/importer"
	"html/template"
	"os"
	"os/exec"
	"path"
	"reflect"
	"strings"
)

type Generator struct {
	svc        interface{}
	dtoPkgPath string
	data       data
}

func Generate(svc interface{}, dtoPkgPath string) error {
	g := Generator{svc: svc, dtoPkgPath: dtoPkgPath}

	ms, err := g.findMethods()
	if err != nil {
		return err
	}
	es, err := g.findErrors()
	if err != nil {
		return err
	}

	pkg, stc := g.findNames()
	g.data = data{
		Package: pkg,
		Struct:  stc,
		Imports: []string{g.dtoPkgPath},
		Methods: ms,
		Errors:  es,
	}

	if err := g.execTemplate(clientTemplate, "api/api_gen.go"); err != nil {
		return err
	}

	fn := fmt.Sprintf("%s_gen.go", strings.ToLower(stc))
	if err := g.execTemplate(serverTemplate, fn); err != nil {
		return err
	}

	return nil
}

func (g *Generator) execTemplate(t *template.Template, fn string) error {
	os.MkdirAll(path.Dir(fn), os.ModePerm)
	f, err := os.Create(fn)
	if err != nil {
		return err
	}
	t.Execute(f, g.data)
	f.Close()
	err = exec.Command("go", "fmt", fn).Run()
	if err != nil {
		return err
	}
	return nil
}

func (g *Generator) findMethods() ([]method, error) {
	v := reflect.ValueOf(g.svc)
	var ms []method
	for i := 0; i < v.NumMethod(); i++ {
		tm := v.Type().Method(i)

		if tm.Name == "Serve" {
			fmt.Printf("skipping generated method %s", tm.Name)
			continue
		}
		m := v.Method(i)

		if m.Type().NumIn() != 1 &&
			m.Type().NumOut() != 2 {
			fmt.Printf("skipping method %s, unsupported signature\n", tm.Name)
			continue
		}
		if m.Type().Out(1).String() != "error" {
			fmt.Printf("skipping method %s, unsupported signature\n", tm.Name)
			continue
		}

		in := m.Type().In(0).String()
		out := m.Type().Out(0).String()

		if isPointer(in) {
			fmt.Printf("skipping method %s, input arg must be passed by value\n", tm.Name)
			continue
		}
		if !isPointer(out) {
			fmt.Printf("skipping method %s, output arg must be passed by reference\n", tm.Name)
			continue
		}

		ms = append(ms, method{
			Name: tm.Name,
			In:   m.Type().In(0).String(),
			Out:  removePointerPrefix(out),
		})
	}
	return ms, nil
}

func isPointer(typ string) bool {
	return strings.HasPrefix(typ, "*")
}

func removePointerPrefix(typ string) string {
	if isPointer(typ) {
		return typ[1:]
	}
	return typ
}

func (g *Generator) findErrors() ([]string, error) {
	var es []string
	pkg, err := importer.Default().Import(g.dtoPkgPath)
	if err != nil {
		return nil, err
	}
	for _, n := range pkg.Scope().Names() {
		if strings.HasPrefix(n, "Err") {
			es = append(es, fmt.Sprintf("%s.%s", pkg.Name(), n))
		}
	}
	return es, nil
}

func (g *Generator) findNames() (string, string) {
	typ := reflect.TypeOf(g.svc).String()
	typ = removePointerPrefix(typ)
	p := strings.Split(typ, ".")
	// TODO sta ako nije len = 2
	return p[0], p[1]
}

type data struct {
	Package string
	Struct  string
	Imports []string
	Methods []method
	Errors  []string
}

type method struct {
	Name string
	In   string
	Out  string
}

var clientTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package api

import (
	"encoding/json"

{{- range .Imports }}
  "{{ . }}"
{{- end }}
)

type transport interface {
	Call(string, []byte) ([]byte, error) 
  Close()
}

type Client struct {
  t transport
}

func NewClient(r transport) *Client {
  return &Client{t: r}
}

{{- range .Methods }}

func (c *Client) {{.Name}}(req {{ .In }}) (*{{ .Out }}, error) {
  rsp := new({{ .Out }})
  if err := c.call("{{.Name}}",req, rsp); err != nil {
    return nil, parseError(err)
  }
  return rsp, nil
}
{{- end }}

func (c *Client) call(typ string, req, rsp interface{}) error {
	reqBuf, err := json.Marshal(req)
	if err != nil {
		return err
	}
	rspBuf, err := c.t.Call(typ, reqBuf)
	if err != nil {
		return err
	}
	if err := json.Unmarshal(rspBuf, rsp); err != nil {
		return err
	}
	return nil
}

func (c *Client) Close() {
	c.t.Close()
}

func parseError(err error) error {
	if err == nil {
		return nil
	}
	switch err.Error() {
{{- range .Errors }}
  case {{ . }}.Error():
    return {{ . }}
{{- end }}
  }
	return err
}
`))

var serverTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package {{.Package}}

import (
	"encoding/json"
	"fmt"

{{- range .Imports }}
  "{{ . }}"
{{- end }}
)

func (s *{{.Struct}}) Serve(typ string, buf []byte) ([]byte, error) {
  switch typ {
  {{- range .Methods }}
	case "{{.Name}}":
		var req {{.In}}
		if err := json.Unmarshal(buf, &req); err != nil {
			return nil, err
		}
		rsp, err := s.{{.Name}}(req)
		if err != nil {
			return nil, err
		}
		return json.Marshal(rsp)
  {{- end }}
	default:
		return nil, fmt.Errorf("unknown type %s", typ)
	}
}
`))

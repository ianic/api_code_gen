package gen

import "text/template"

var apiTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package api

import (
	"encoding/json"
    "errors"
)

// method names constants
const (
{{- range .Methods }}
  Method{{.Name}} = "{{.Name}}"
{{- end}}
  transportRetries = {{.TransportRetries}}
)

// transport specific errors
var (
  ErrTransportTimeout = errors.New("transport timeout")
  ErrTransport        = errors.New("transport error")
)

type transport interface {
  Call(string, []byte) ([]byte, error) 
  Close()
}

type Client struct {
  t transport
}

func NewClient(r transport) *Client {
  return &Client{t: r}
}

{{- range .Methods }}

func (c *Client) {{.Name}}(req {{ .In }}) (*{{ .Out }}, error) {
  rsp := new({{ .Out }})
  if err := c.call(Method{{.Name}},req, rsp); err != nil {
    return nil, parseError(err)
  }
  return rsp, nil
}
{{- end }}

func (c *Client) call(method string, req, rsp interface{}) error {
	reqBuf, err := Marshal(req)
	if err != nil {
		return err
	}
    var rspBuf []byte
    retries := 0
    for {
      var err error
  	  rspBuf, err = c.t.Call(method, reqBuf)
	  if err != nil {
        if err == ErrTransportTimeout && retries < transportRetries {
          retries++
          continue
        }
        if err == ErrTransportTimeout {
          return ErrTransport
        }
		return err
	  }
      break
    }
	if err := Unmarshal(rspBuf, rsp); err != nil {
		return err
	}
	return nil
}

func (c *Client) Close() {
	c.t.Close()
}

func parseError(err error) error {
	if err == nil {
		return nil
	}
	switch err.Error() {
{{- range .Errors }}
  case {{ . }}.Error():
    return {{ . }}
{{- end }}
  }
	return err
}

func Marshal(v interface{}) ([]byte, error) {
	return json.Marshal(v)
}

func Unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}
`))
